# üöÄ PROMPT COMPLETO PARA O REPLIT - V2

## Aplicativo de Visualiza√ß√£o de Fun√ß√µes Quadr√°ticas Complexas

---

Voc√™ √© o Manus, um sistema avan√ßado de forma√ß√£o de equipes de desenvolvimento. Sua miss√£o √© analisar o objetivo de um aplicativo e formar automaticamente a equipe perfeita de especialistas para desenvolv√™-lo com excel√™ncia.

**OBJETIVO DO APLICATIVO:**
"Quero criar um aplicativo web tipo GeoGebra para visualizar gr√°ficos de fun√ß√µes quadr√°ticas em vari√°vel complexa, baseado no livro 'C√°lculo em uma Vari√°vel Complexa' de Marco G. Soares, que permita aos estudantes universit√°rios explorar e compreender visualmente o comportamento dessas fun√ß√µes atrav√©s de t√©cnicas como domain coloring e gr√°ficos 3D interativos."

---

### üéØ AN√ÅLISE DO OBJETIVO

**Complexidade:** M√©dia a Alta
- Requer manipula√ß√£o avan√ßada de n√∫meros complexos
- Visualiza√ß√£o de fun√ß√µes ‚ÑÇ ‚Üí ‚ÑÇ (4 dimens√µes em 2D/3D)
- Algoritmos de domain coloring e renderiza√ß√£o 3D
- Interface interativa com controles matem√°ticos precisos

**Dom√≠nio:** Educa√ß√£o/Matem√°tica
- Ferramenta educacional para An√°lise Complexa
- P√∫blico universit√°rio (estudantes e professores)
- Baseado em literatura acad√™mica espec√≠fica (Marco G. Soares)

**Tecnologias Necess√°rias:**
- Frontend web com visualiza√ß√£o avan√ßada
- Bibliotecas matem√°ticas para n√∫meros complexos
- Engines de renderiza√ß√£o 2D/3D (WebGL)
- Interface responsiva e intuitiva

**Requisitos Especiais:**
- Alta precis√£o matem√°tica (erro < 1e-12)
- Performance otimizada para renderiza√ß√£o em tempo real
- Interatividade fluida (zoom, pan, rota√ß√£o)
- Compatibilidade com navegadores educacionais

**P√∫blico-alvo:**
- B2C: Estudantes de Matem√°tica, Engenharia, F√≠sica
- Professores universit√°rios de An√°lise Complexa
- Pesquisadores em matem√°tica aplicada

---

### üë• EQUIPE FORMADA

#### **1. Dr. Marina Oliveira** - Gestora de Produto Educacional
- **Cargo:** Product Manager Senior
- **Experi√™ncia:** 9 anos em produtos EdTech e ferramentas matem√°ticas
- **Especialidades:** Gest√£o de produtos educacionais, UX Research acad√™mico, metodologias √°geis para educa√ß√£o
- **Personalidade:** Focada no impacto educacional, orientada por dados de engajamento e feedback de usu√°rios
- **Comunica√ß√£o:** Direta e baseada em resultados, sempre questiona o valor educacional

#### **2. Prof. Ricardo Mendes** - Tech Lead & Especialista Matem√°tico
- **Cargo:** Senior Software Architect & Mathematics Consultant
- **Experi√™ncia:** 15 anos em software matem√°tico + 8 anos como professor de An√°lise Complexa
- **Especialidades:** Arquitetura para aplica√ß√µes matem√°ticas, algoritmos de visualiza√ß√£o complexa, otimiza√ß√£o num√©rica
- **Personalidade:** Vision√°rio t√©cnico com base acad√™mica s√≥lida, preocupado com corre√ß√£o e escalabilidade
- **Comunica√ß√£o:** Did√°tico e preciso, usa analogias para explicar conceitos t√©cnicos

#### **3. Ana Paula Santos** - Desenvolvedora Frontend Especialista
- **Cargo:** Senior Frontend Developer
- **Experi√™ncia:** 7 anos em desenvolvimento web, 4 anos em visualiza√ß√£o de dados
- **Especialidades:** React/TypeScript, Plotly.js/D3.js/Three.js, WebGL/Canvas, responsive design
- **Personalidade:** Criativa e perfeccionista, obcecada por performance e UX
- **Comunica√ß√£o:** Entusiasta e detalhista, demonstra conceitos com prot√≥tipos visuais

#### **4. Carlos Eduardo Lima** - Desenvolvedor Backend & DevOps
- **Cargo:** Full Stack Developer com foco em Backend
- **Experi√™ncia:** 10 anos em backend, 5 anos com DevOps
- **Especialidades:** Node.js/Python para APIs matem√°ticas, otimiza√ß√£o de algoritmos, Docker/CI-CD
- **Personalidade:** Pragm√°tico e focado em solu√ß√µes robustas, pensa em manutenibilidade
- **Comunica√ß√£o:** Objetivo e t√©cnico, discute trade-offs e alternativas

#### **5. Beatriz Ferreira** - Designer UI/UX Educacional
- **Cargo:** Senior UX/UI Designer
- **Experi√™ncia:** 8 anos em design, 5 anos em produtos educacionais
- **Especialidades:** Interfaces para ferramentas matem√°ticas, usabilidade acad√™mica, design systems
- **Personalidade:** Emp√°tica e centrada no usu√°rio, defende simplicidade e intuitividade
- **Comunica√ß√£o:** Visual e colaborativa, usa sketches e wireframes

#### **6. Dr. Felipe Rodrigues** - Especialista em An√°lise Complexa & QA
- **Cargo:** Mathematics Consultant & Quality Assurance Lead
- **Experi√™ncia:** 12 anos como professor universit√°rio, 6 anos em consultoria matem√°tica
- **Especialidades:** Teoria de fun√ß√µes complexas, valida√ß√£o de algoritmos, testes de precis√£o
- **Personalidade:** Meticuloso e acad√™mico, preocupado com corre√ß√£o te√≥rica
- **Comunica√ß√£o:** Formal e preciso, fundamenta argumentos com teoria matem√°tica

---

### üó£Ô∏è REUNI√ÉO DE KICKOFF - FOCO NA VISUALIZA√á√ÉO

**Moderador:** Prof. Ricardo Mendes (Tech Lead)

---

**Ricardo:** "Bom dia, equipe! Hoje, nosso foco √© o cora√ß√£o do aplicativo: como vamos transformar as fun√ß√µes quadr√°ticas complexas em visualiza√ß√µes interativas. Ana Paula, Carlos, Felipe, vamos mergulhar nos detalhes t√©cnicos. Ana Paula, voc√™ pode come√ßar com suas ideias para o frontend?"

---

#### **DISCUSS√ÉO T√âCNICA APROFUNDADA**

**Ana Paula (Frontend Developer):**
"Minha proposta √© usar uma combina√ß√£o de Plotly.js para os gr√°ficos 3D de superf√≠cie e um canvas HTML5 com WebGL para o *domain coloring*. Plotly √© √≥timo para interatividade pronta, mas para o *domain coloring*, onde cada pixel representa um ponto no plano complexo e sua cor √© determinada pelo valor da fun√ß√£o, precisamos de controle mais granular e performance. WebGL nos permite escrever shaders que far√£o o c√°lculo da fun√ß√£o e a convers√£o de cores diretamente na GPU, o que √© crucial para renderiza√ß√£o em tempo real."

**Carlos Eduardo Lima (Backend/DevOps):**
"Ana Paula, essa abordagem com WebGL √© excelente para performance no cliente. Minha preocupa√ß√£o √© com a complexidade dos c√°lculos para fun√ß√µes mais elaboradas ou para grids muito densos. Voc√™s planejam fazer o c√°lculo da fun√ß√£o no frontend ou teremos um endpoint no backend para isso? Se for no frontend, precisamos garantir que a biblioteca de n√∫meros complexos seja otimizada e que n√£o trave a UI. Talvez Web Workers para os c√°lculos intensivos?"

**Ana Paula:**
"Boa pergunta, Carlos. Para as fun√ß√µes quadr√°ticas, que s√£o relativamente simples, podemos fazer a avalia√ß√£o diretamente no frontend usando `math.js` ou uma biblioteca customizada de n√∫meros complexos. A ideia √© que o WebGL receba os par√¢metros da fun√ß√£o e o dom√≠nio, e o shader fa√ßa a itera√ß√£o pixel a pixel. Para evitar travamentos, sim, Web Workers seriam ideais para pr√©-processamento de dados ou para gerar os dados iniciais para o Plotly, antes de pass√°-los para o thread principal."

**Dr. Felipe Rodrigues (Especialista Matem√°tico/QA):**
"Do ponto de vista matem√°tico, a representa√ß√£o do *domain coloring* √© fundamental. Precisamos garantir que a convers√£o de fase e m√≥dulo para cor (HSV para RGB) seja matematicamente correta e visualmente intuitiva. O m√≥dulo de f(z) deve influenciar a intensidade/brilho, e o argumento (fase) deve mapear para o matiz (hue). Precisamos de uma fun√ß√£o `hsvToRgb` robusta. Al√©m disso, para os gr√°ficos 3D, a superf√≠cie `|f(z)|` sobre o plano z √© uma boa escolha, mas tamb√©m podemos considerar `Re(f(z))` ou `Im(f(z))` como altura, com a cor representando a fase."

**Ricardo (Tech Lead):**
"Concordo, Felipe. A precis√£o da convers√£o de cores √© vital para a interpreta√ß√£o matem√°tica. Ana Paula, voc√™ j√° tem alguma ideia de como estruturar a entrada da fun√ß√£o? O usu√°rio digitar√° a express√£o `az^2 + bz + c` ou teremos campos separados para `a`, `b`, `c` (com partes real e imagin√°ria)?"

**Ana Paula:**
"Minha ideia inicial √© ter campos separados para a parte real e imagin√°ria de `a`, `b` e `c`. Isso simplifica o parsing e garante que o usu√°rio insira n√∫meros complexos corretamente. Podemos ter um parser mais avan√ßado no futuro, mas para o MVP, campos separados s√£o mais seguros. Para a visualiza√ß√£o 3D, Plotly.js √© excelente, pois j√° lida com superf√≠cies e interatividade. Para o *domain coloring*, o canvas com WebGL nos d√° total controle sobre o mapeamento de cores."

**Carlos:**
"Se os c√°lculos forem no frontend, vou focar em otimizar a entrega dos assets e garantir que o ambiente de build do React seja o mais eficiente poss√≠vel. Tamb√©m posso ajudar a configurar os Web Workers e a otimizar a comunica√ß√£o entre eles e o thread principal. Para o backend, podemos ter um servi√ßo leve para persist√™ncia de fun√ß√µes salvas ou exemplos, se decidirmos por isso mais tarde."

**Ricardo:**
"√ìtimo. Ent√£o, para resumir a abordagem t√©cnica da visualiza√ß√£o:
1. **Input:** Campos separados para Re/Im de a, b, c.
2. **C√°lculo:** Frontend com `math.js` ou biblioteca customizada de complexos. Web Workers para c√°lculos intensivos.
3. **Visualiza√ß√£o 2D (Domain Coloring):** Canvas HTML5 + WebGL para renderiza√ß√£o de alta performance, com shader para mapeamento HSV para RGB.
4. **Visualiza√ß√£o 3D (Superf√≠cie):** Plotly.js para `|f(z)|` sobre o plano z, com interatividade pronta.
5. **Valida√ß√£o:** Felipe, voc√™ ser√° crucial para validar a corre√ß√£o matem√°tica das visualiza√ß√µes e dos algoritmos de convers√£o de cores."

**Felipe:**
"Perfeito. Vou preparar um conjunto de testes de valida√ß√£o para o *domain coloring* e para os gr√°ficos 3D, incluindo casos com ra√≠zes, polos e diferentes comportamentos assint√≥ticos, baseados nos exemplos do livro do Marco G. Soares."

**Ana Paula:**
"Vou come√ßar a prototipar o componente de *domain coloring* com WebGL e o componente de input de fun√ß√£o. Preciso de um esqueleto da biblioteca de n√∫meros complexos para come√ßar."

**Carlos:**
"Vou configurar o ambiente de desenvolvimento para suportar Web Workers e garantir que o build do frontend inclua as otimiza√ß√µes necess√°rias para o WebGL."

**Ricardo:**
"Excelente! Pr√≥xima reuni√£o, quero ver os primeiros prot√≥tipos de visualiza√ß√£o e a estrutura da biblioteca de n√∫meros complexos. Vamos manter a comunica√ß√£o fluida para resolver qualquer impedimento. Obrigado a todos!"

---

### üìã PLANO DE DESENVOLVIMENTO

#### **CRONOGRAMA: 8 SEMANAS**

**FASE 1: FUNDA√á√ÉO E ARQUITETURA** *(Semana 1)*
- **Respons√°vel:** Ricardo Mendes
- **Tecnologias:** React 18 + TypeScript + Vite, math.js, Plotly.js, Three.js
- **Entreg√°veis:** Arquitetura documentada, ambiente configurado, CI/CD b√°sico
- **Crit√©rios:** Documenta√ß√£o completa, ambiente reproduz√≠vel

**FASE 2: DESIGN E PROTOTIPAGEM** *(Semana 2)*
- **Respons√°vel:** Beatriz Ferreira  
- **Tecnologias:** Figma, Storybook, Tailwind CSS + shadcn/ui
- **Entreg√°veis:** Wireframes, prot√≥tipo naveg√°vel, sistema de design
- **Crit√©rios:** Interface intuitiva, acessibilidade WCAG 2.1 AA

**FASE 3: CORE MATEM√ÅTICO** *(Semana 3)*
- **Respons√°vel:** Felipe Rodrigues
- **Tecnologias:** math.js customizado, Jest para testes
- **Entreg√°veis:** Biblioteca de complexos, algoritmos domain coloring, testes
- **Crit√©rios:** Precis√£o < 1e-12, performance < 100ms, cobertura > 95%

**FASE 4: VISUALIZA√á√ÉO B√ÅSICA** *(Semana 4)*
- **Respons√°vel:** Ana Paula Santos
- **Tecnologias:** Plotly.js, Three.js, WebGL shaders
- **Entreg√°veis:** Domain coloring 2D, gr√°ficos 3D, controles interativos
- **Crit√©rios:** 60 FPS, cores matematicamente precisas

**FASE 5: INTERFACE DE USU√ÅRIO** *(Semana 5)*
- **Respons√°vel:** Ana Paula Santos
- **Tecnologias:** React + shadcn/ui, React Hook Form, Zustand
- **Entreg√°veis:** Interface completa, entrada de fun√ß√µes, pain√©is de controle
- **Crit√©rios:** Design system implementado, valida√ß√£o em tempo real

**FASE 6: FUNCIONALIDADES AVAN√áADAS** *(Semana 6)*
- **Respons√°vel:** Ricardo Mendes
- **Tecnologias:** Framer Motion, m√∫ltiplas views, base de exemplos
- **Entreg√°veis:** Anima√ß√µes, visualiza√ß√µes simult√¢neas, exemplos educacionais
- **Crit√©rios:** Anima√ß√µes matematicamente corretas, performance mantida

**FASE 7: OTIMIZA√á√ÉO E POLIMENTO** *(Semana 7)*
- **Respons√°vel:** Carlos Eduardo Lima
- **Tecnologias:** Service Workers, IndexedDB, Cypress, Sentry
- **Entreg√°veis:** Performance otimizada, cache, testes E2E, monitoramento
- **Crit√©rios:** Lighthouse > 90, funcionalidade offline, cobertura > 80%

**FASE 8: DEPLOY E DOCUMENTA√á√ÉO** *(Semana 8)*
- **Respons√°vel:** Marina Oliveira
- **Tecnologias:** Vercel, Railway, GitBook, Google Analytics
- **Entreg√°veis:** Produ√ß√£o est√°vel, documenta√ß√£o, guia para professores
- **Crit√©rios:** Uptime > 99.9%, documenta√ß√£o abrangente

#### **STACK TECNOL√ìGICO CONSOLIDADO:**

**Frontend:**
- React 18 + TypeScript + Vite
- Tailwind CSS + shadcn/ui
- Plotly.js + D3.js + Three.js
- math.js + bibliotecas matem√°ticas customizadas
- Zustand (estado) + React Hook Form (formul√°rios)

**Backend:**
- Node.js + Express + TypeScript
- Bibliotecas matem√°ticas otimizadas
- Redis para cache

**DevOps:**
- Docker + GitHub Actions
- Vercel (frontend) + Railway (backend)
- Sentry (monitoramento) + Lighthouse (performance)

**Qualidade:**
- Jest (testes unit√°rios) + Cypress (E2E)
- Storybook (componentes) + ESLint + Prettier

---

### üíª IMPLEMENTA√á√ÉO COMPLETA

#### **ESTRUTURA DO PROJETO**

```
complex-function-visualizer/
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/                 # shadcn/ui components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FunctionInput.tsx   # Input de fun√ß√µes complexas
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Visualizer2D.tsx    # Domain coloring 2D
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Visualizer3D.tsx    # Gr√°ficos 3D
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ControlPanel.tsx    # Controles e par√¢metros
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PropertiesPanel.tsx # Propriedades da fun√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ complex.ts          # Biblioteca de n√∫meros complexos
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ functions.ts        # Fun√ß√µes quadr√°ticas
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain-coloring.ts  # Algoritmos de colora√ß√£o
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ examples.ts         # Exemplos do livro
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useFunction.ts      # Hook para fun√ß√µes
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useVisualization.ts # Hook para visualiza√ß√£o
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app-store.ts        # Estado global Zustand
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.tsx
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ calculate.ts        # Endpoints de c√°lculo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ complex-math.ts     # Matem√°tica complexa
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.ts            # Sistema de cache
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ server.ts
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ user-guide.md
‚îÇ   ‚îú‚îÄ‚îÄ mathematical-reference.md
‚îÇ   ‚îî‚îÄ‚îÄ api-documentation.md
‚îî‚îÄ‚îÄ docker-compose.yml
```

#### **C√ìDIGO PRINCIPAL**

**1. Biblioteca de N√∫meros Complexos (frontend/src/lib/complex.ts)**

```typescript
export class Complex {
  constructor(public real: number, public imag: number) {}

  static fromPolar(r: number, theta: number): Complex {
    return new Complex(r * Math.cos(theta), r * Math.sin(theta));
  }

  add(other: Complex): Complex {
    return new Complex(this.real + other.real, this.imag + other.imag);
  }

  multiply(other: Complex): Complex {
    return new Complex(
      this.real * other.real - this.imag * other.imag,
      this.real * other.imag + this.imag * other.real
    );
  }

  magnitude(): number {
    return Math.sqrt(this.real * this.real + this.imag * this.imag);
  }

  argument(): number {
    return Math.atan2(this.imag, this.real);
  }

  toString(): string {
    const sign = this.imag >= 0 ? '+' : '-';
    return `${this.real} ${sign} ${Math.abs(this.imag)}i`;
  }

  // Adicionar m√©todos para subtra√ß√£o, divis√£o, raiz quadrada, etc.
  subtract(other: Complex): Complex {
    return new Complex(this.real - other.real, this.imag - other.imag);
  }

  divide(other: Complex): Complex {
    const denominator = other.real * other.real + other.imag * other.imag;
    return new Complex(
      (this.real * other.real + this.imag * other.imag) / denominator,
      (this.imag * other.real - this.real * other.imag) / denominator
    );
  }

  negate(): Complex {
    return new Complex(-this.real, -this.imag);
  }

  sqrt(): Complex {
    const r = this.magnitude();
    const theta = this.argument();
    const sqrt_r = Math.sqrt(r);
    const half_theta = theta / 2;
    return new Complex(sqrt_r * Math.cos(half_theta), sqrt_r * Math.sin(half_theta));
  }
}
```

**2. Fun√ß√µes Quadr√°ticas (frontend/src/lib/functions.ts)**

```typescript
import { Complex } from './complex';

export class QuadraticFunction {
  constructor(
    private a: Complex,
    private b: Complex,
    private c: Complex
  ) {}

  evaluate(z: Complex): Complex {
    // f(z) = az¬≤ + bz + c
    const z_squared = z.multiply(z);
    return this.a.multiply(z_squared)
      .add(this.b.multiply(z))
      .add(this.c);
  }

  getRoots(): [Complex, Complex] {
    // F√≥rmula quadr√°tica para n√∫meros complexos
    // z = (-b ¬± ‚àö(b¬≤ - 4ac)) / 2a
    const discriminant = this.b.multiply(this.b)
      .subtract(this.a.multiply(this.c).multiply(new Complex(4, 0)));
    
    const sqrt_discriminant = discriminant.sqrt();
    const two_a = this.a.multiply(new Complex(2, 0));
    
    const root1 = this.b.negate().add(sqrt_discriminant).divide(two_a);
    const root2 = this.b.negate().subtract(sqrt_discriminant).divide(two_a);
    
    return [root1, root2];
  }

  getVertex(): Complex {
    // V√©rtice: z = -b / 2a
    return this.b.negate().divide(this.a.multiply(new Complex(2, 0)));
  }
}
```

**3. Domain Coloring (frontend/src/lib/domain-coloring.ts)**

```typescript
import { Complex } from './complex';
import { QuadraticFunction } from './functions';

export function generateDomainColoring(
  func: QuadraticFunction,
  width: number,
  height: number,
  bounds: { xMin: number, xMax: number, yMin: number, yMax: number }
): ImageData {
  const canvas = new OffscreenCanvas(width, height);
  const ctx = canvas.getContext('2d')!;
  const imageData = ctx.createImageData(width, height);
  
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      // Mapear pixel para n√∫mero complexo
      const real = bounds.xMin + (x / width) * (bounds.xMax - bounds.xMin);
      const imag = bounds.yMin + (y / height) * (bounds.yMax - bounds.yMin);
      const z = new Complex(real, imag);
      
      // Avaliar fun√ß√£o
      const result = func.evaluate(z);
      
      // Converter para cor HSV
      const hue = (result.argument() + Math.PI) / (2 * Math.PI); // [0, 1]
      const saturation = 1;
      const value = Math.min(1, result.magnitude() / 10); // Normalizar
      
      // Converter HSV para RGB
      const rgb = hsvToRgb(hue, saturation, value);
      
      // Definir pixel
      const index = (y * width + x) * 4;
      imageData.data[index] = rgb.r;
      imageData.data[index + 1] = rgb.g;
      imageData.data[index + 2] = rgb.b;
      imageData.data[index + 3] = 255;
    }
  }
  
  return imageData;
}

function hsvToRgb(h: number, s: number, v: number): {r: number, g: number, b: number} {
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  let r = 0, g = 0, b = 0;

  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
```

**4. Componente Visualizer2D (frontend/src/components/Visualizer2D.tsx)**

```tsx
import React, { useRef, useEffect } from 'react';
import { QuadraticFunction } from '../lib/functions';
import { generateDomainColoring } from '../lib/domain-coloring';

interface Visualizer2DProps {
  function: QuadraticFunction;
  bounds: { xMin: number; xMax: number; yMin: number; yMax: number };
}

export const Visualizer2D: React.FC<Visualizer2DProps> = ({ function: func, bounds }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const width = canvas.width;
    const height = canvas.height;

    // Gerar o domain coloring
    const imageData = generateDomainColoring(func, width, height, bounds);
    ctx.putImageData(imageData, 0, 0);
  }, [func, bounds]);

  return (
    <div className="w-full h-full flex items-center justify-center">
      <canvas ref={canvasRef} width={800} height={800} className="border" />
    </div>
  );
};
```

**5. Componente Visualizer3D (frontend/src/components/Visualizer3D.tsx)**

```tsx
import React from 'react';
import Plot from 'react-plotly.js';
import { QuadraticFunction } from '../lib/functions';
import { Complex } from '../lib/complex';

interface Visualizer3DProps {
  function: QuadraticFunction;
  bounds: { xMin: number; xMax: number; yMin: number; yMax: number };
}

export const Visualizer3D: React.FC<Visualizer3DProps> = ({ function: func, bounds }) => {
  const { xMin, xMax, yMin, yMax } = bounds;
  const numPoints = 50; // Resolu√ß√£o do grid

  const xValues: number[] = [];
  const yValues: number[] = [];
  const zValues: number[][] = [];
  const colors: string[][] = []; // Para domain coloring na superf√≠cie

  for (let i = 0; i < numPoints; i++) {
    const rowZ: number[] = [];
    const rowColors: string[] = [];
    const x = xMin + (i / (numPoints - 1)) * (xMax - xMin);
    xValues.push(x);

    for (let j = 0; j < numPoints; j++) {
      const y = yMin + (j / (numPoints - 1)) * (yMax - yMin);
      if (i === 0) yValues.push(y);

      const z_complex = new Complex(x, y);
      const f_z = func.evaluate(z_complex);

      rowZ.push(f_z.magnitude());

      // Gerar cor baseada na fase para a superf√≠cie 3D
      const hue = (f_z.argument() + Math.PI) / (2 * Math.PI);
      const saturation = 1;
      const value = Math.min(1, f_z.magnitude() / 10);
      const rgb = hsvToRgb(hue, saturation, value);
      rowColors.push(`rgb(${rgb.r},${rgb.g},${rgb.b})`);
    }
    zValues.push(rowZ);
    colors.push(rowColors);
  }

  // Fun√ß√£o auxiliar para HSV para RGB (duplicada para auto-sufici√™ncia do snippet)
  function hsvToRgb(h: number, s: number, v: number): {r: number, g: number, b: number} {
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    let r = 0, g = 0, b = 0;
  
    switch (i % 6) {
      case 0: r = v; g = t; b = p; break;
      case 1: r = q; g = v; b = p; break;
      case 2: r = p; g = v; b = t; break;
      case 3: r = p; g = q; b = v; break;
      case 4: r = t; g = p; b = v; break;
      case 5: r = v; g = p; b = q; break;
    }
  
    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }

  const data: Plotly.Data[] = [
    {
      type: 'surface',
      x: xValues,
      y: yValues,
      z: zValues,
      surfacecolor: colors,
      colorbar: { title: 'Fase de f(z)' },
      colorscale: 'Viridis', // Apenas para a barra de cores, o surfacecolor define as cores
    },
  ];

  const layout: Partial<Plotly.Layout> = {
    title: '|f(z)| Surface Plot',
    autosize: true,
    margin: { l: 0, r: 0, b: 0, t: 0 },
    scene: {
      xaxis: { title: 'Re(z)' },
      yaxis: { title: 'Im(z)' },
      zaxis: { title: '|f(z)|' },
      aspectmode: 'cube',
    },
  };

  return (
    <Plot
      data={data}
      layout={layout}
      useResizeHandler={true}
      style={{ width: '100%', height: '100%' }}
      config={{ responsive: true }}
    />
  );
};
```

**6. Componente FunctionInput (frontend/src/components/FunctionInput.tsx)**

```tsx
import React, { useState } from 'react';
import { Complex } from '../lib/complex';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';

interface FunctionInputProps {
  onFunctionChange: (a: Complex, b: Complex, c: Complex) => void;
}

export const FunctionInput: React.FC<FunctionInputProps> = ({ onFunctionChange }) => {
  const [aReal, setAReal] = useState('1');
  const [aImag, setAImag] = useState('0');
  const [bReal, setBReal] = useState('0');
  const [bImag, setBImag] = useState('0');
  const [cReal, setCReal] = useState('0');
  const [cImag, setCImag] = useState('0');

  const handleSubmit = () => {
    try {
      const a = new Complex(parseFloat(aReal), parseFloat(aImag));
      const b = new Complex(parseFloat(bReal), parseFloat(bImag));
      const c = new Complex(parseFloat(cReal), parseFloat(cImag));
      onFunctionChange(a, b, c);
    } catch (error) {
      alert('Por favor, insira n√∫meros v√°lidos para a, b e c.');
    }
  };

  return (
    <div className="space-y-4">
      <h2 className="text-lg font-semibold">Fun√ß√£o Quadr√°tica: f(z) = az¬≤ + bz + c</h2>
      
      <div>
        <Label htmlFor="a-real">Coeficiente 'a' (Real)</Label>
        <Input id="a-real" type="number" value={aReal} onChange={(e) => setAReal(e.target.value)} />
        <Label htmlFor="a-imag">Coeficiente 'a' (Imagin√°rio)</Label>
        <Input id="a-imag" type="number" value={aImag} onChange={(e) => setAImag(e.target.value)} />
      </div>

      <div>
        <Label htmlFor="b-real">Coeficiente 'b' (Real)</Label>
        <Input id="b-real" type="number" value={bReal} onChange={(e) => setBReal(e.target.value)} />
        <Label htmlFor="b-imag">Coeficiente 'b' (Imagin√°rio)</Label>
        <Input id="b-imag" type="number" value={bImag} onChange={(e) => setBImag(e.target.value)} />
      </div>

      <div>
        <Label htmlFor="c-real">Coeficiente 'c' (Real)</Label>
        <Input id="c-real" type="number" value={cReal} onChange={(e) => setCReal(e.target.value)} />
        <Label htmlFor="c-imag">Coeficiente 'c' (Imagin√°rio)</Label>
        <Input id="c-imag" type="number" value={cImag} onChange={(e) => setCImag(e.target.value)} />
      </div>

      <Button onClick={handleSubmit}>Atualizar Gr√°fico</Button>
    </div>
  );
};
```

**7. Componente ControlPanel (frontend/src/components/ControlPanel.tsx)**

```tsx
import React from 'react';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';

interface ControlPanelProps {
  bounds: { xMin: number; xMax: number; yMin: number; yMax: number };
  onBoundsChange: (bounds: { xMin: number; xMax: number; yMin: number; yMax: number }) => void;
}

export const ControlPanel: React.FC<ControlPanelProps> = ({ bounds, onBoundsChange }) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    onBoundsChange({ ...bounds, [name]: parseFloat(value) });
  };

  return (
    <div className="space-y-4">
      <h2 className="text-lg font-semibold">Controles de Visualiza√ß√£o</h2>
      <div>
        <Label htmlFor="xMin">X M√≠nimo</Label>
        <Input id="xMin" name="xMin" type="number" value={bounds.xMin} onChange={handleChange} />
      </div>
      <div>
        <Label htmlFor="xMax">X M√°ximo</Label>
        <Input id="xMax" name="xMax" type="number" value={bounds.xMax} onChange={handleChange} />
      </div>
      <div>
        <Label htmlFor="yMin">Y M√≠nimo</Label>
        <Input id="yMin" name="yMin" type="number" value={bounds.yMin} onChange={handleChange} />
      </div>
      <div>
        <Label htmlFor="yMax">Y M√°ximo</Label>
        <Input id="yMax" name="yMax" type="number" value={bounds.yMax} onChange={handleChange} />
      </div>
    </div>
  );
};
```

**8. Componente PropertiesPanel (frontend/src/components/PropertiesPanel.tsx)**

```tsx
import React from 'react';
import { QuadraticFunction } from '../lib/functions';

interface PropertiesPanelProps {
  function: QuadraticFunction;
}

export const PropertiesPanel: React.FC<PropertiesPanelProps> = ({ function: func }) => {
  const roots = func.getRoots();
  const vertex = func.getVertex();

  return (
    <div className="space-y-4">
      <h2 className="text-lg font-semibold">Propriedades da Fun√ß√£o</h2>
      <div>
        <p><strong>Raiz 1:</strong> {roots[0].toString()}</p>
        <p><strong>Raiz 2:</strong> {roots[1].toString()}</p>
      </div>
      <div>
        <p><strong>V√©rtice:</strong> {vertex.toString()}</p>
      </div>
      {/* Adicionar mais propriedades conforme necess√°rio */}
    </div>
  );
};
```

**9. Componente Principal (frontend/src/App.tsx) - Atualizado**

```tsx
import React, { useState, useCallback } from 'react';
import { FunctionInput } from './components/FunctionInput';
import { Visualizer2D } from './components/Visualizer2D';
import { Visualizer3D } from './components/Visualizer3D';
import { ControlPanel } from './components/ControlPanel';
import { PropertiesPanel } from './components/PropertiesPanel';
import { QuadraticFunction } from './lib/functions';
import { Complex } from './lib/complex';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';

export default function App() {
  const [currentFunction, setCurrentFunction] = useState<QuadraticFunction>(
    new QuadraticFunction(
      new Complex(1, 0),  // a = 1
      new Complex(0, 0),  // b = 0
      new Complex(0, 0)   // c = 0
    )
  );
  
  const [bounds, setBounds] = useState({
    xMin: -3, xMax: 3, yMin: -3, yMax: 3
  });

  const handleFunctionChange = useCallback((a: Complex, b: Complex, c: Complex) => {
    setCurrentFunction(new QuadraticFunction(a, b, c));
  }, []);

  return (
    <div className="min-h-screen bg-background">
      <header className="border-b p-4">
        <h1 className="text-2xl font-bold">
          Visualizador de Fun√ß√µes Quadr√°ticas Complexas
        </h1>
        <p className="text-muted-foreground">
          Baseado no livro "C√°lculo em uma Vari√°vel Complexa" - Marco G. Soares
        </p>
      </header>
      
      <div className="flex h-[calc(100vh-80px)]">
        {/* Painel Esquerdo */}
        <div className="w-80 border-r p-4 space-y-4">
          <FunctionInput onFunctionChange={handleFunctionChange} />
          <ControlPanel bounds={bounds} onBoundsChange={setBounds} />
        </div>
        
        {/* √Årea Central */}
        <div className="flex-1 p-4">
          <Tabs defaultValue="2d" className="h-full">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="2d">Domain Coloring 2D</TabsTrigger>
              <TabsTrigger value="3d">Superf√≠cie 3D</TabsTrigger>
            </TabsList>
            
            <TabsContent value="2d" className="h-[calc(100%-40px)]">
              <Visualizer2D 
                function={currentFunction} 
                bounds={bounds}
              />
            </TabsContent>
            
            <TabsContent value="3d" className="h-[calc(100%-40px)]">
              <Visualizer3D 
                function={currentFunction} 
                bounds={bounds}
              />
            </TabsContent>
          </Tabs>
        </div>
        
        {/* Painel Direito */}
        <div className="w-80 border-l p-4">
          <PropertiesPanel function={currentFunction} />
        </div>
      </div>
    </div>
  );
}
```

**10. Backend API (backend/src/server.ts) - Mantido**

```typescript
import express from 'express';
import cors from 'cors';
import { calculateRoute } from './routes/calculate';

const app = express();
const PORT = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// Rotas
app.use('/api/calculate', calculateRoute);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});
```

**11. Docker Compose (docker-compose.yml) - Mantido**

```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_URL=http://localhost:3001
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis

  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
```

---

